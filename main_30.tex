\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

\title{Assignment 30}
\author{Xiaoting Li (xil139) \\
Ziyu Zhang (ziz41) \\
Deniz Unal (des204)}
\date{April 5 2019}

\begin{document}

\maketitle

\noindent
\textbf{54. Problem 15-3 from the text. The purpose of this problem is to give you some practice coming up with a dynamic program.} \\ \newline
Answer: We first order $n$ points in increasing order based on their x-coordinate. From left to right, we denote the points as $p_1, p_2,..., p_n$. We also denote the euclidean distance between $p_i$ and $p_j$ as $d(i, j)$, and denote the length of the shortest bitonic path between $p_i$ and $p_j$ as $b(i, j)$. From the hint, we can think this as a binary tree, so level to level, we have $b(1, 2), b(1, 3) b(2, 3), b(1, 4), b(2, 4), ...,b(i, j)$. We know that bitonic tours are tours that start at the leftmost point and go strictly rightward to the rightmost point, and then go strictly leftward back to the starting point. So all points that are left to the $p_j$ are visited by the tour. So when $i < j - 1$, in order to get $b(i,j)$, we need to know $b(i, j-1)$ and $d(j-1, j)$. We have $b(i,j) = b(i, j-1) + d(j-1, j)$. The baseline is $b(1,2) = d(1,2)$, baseline is simply the euclidean distance between $p_1$ and $p_2$. When $i = j - 1$, we know that there must be some path that gets to $p_k$ and from $p_k$ that gets to $p_j$, and $1 < k < j - 1$. So at this time we need to get the shortest path among all of such points. We can write the dynamic algorithm as 
\begin{flalign*}
&b(1,2) = d(1,2) \\
&b(i,j) = b(i, j-1) + d(j-1, j), \quad i < j - 1 \\
&b(i,j) = min\{b(k, j) + d(k, j)\}, \quad i = j - 1, 1 < k < j - 1
\end{flalign*}
No matter $i < j - 1$ or $i = j - 1$, it takes two for-loops to do the calculation. So the algorithm is $O(n^2)$.
\\ \newline
\textbf{55. The goal in this problem is to give polynomial time approximation scheme (PTAS) for the parallel machine scheduling problem described in problem 35-5 in CLR, for the case that the number of processors/machines $m = 3$, using the following approach:} \\ \newline
\textbf{• First give a dynamic programming algorithm whose time in polynomial in $n$, and $P$, where $P$ is the total aggregate processing times of all of the jobs. So this is a pseudo-polynomial-time algorithm, but not a polynomial time algorithm.} \\ \newline
\textbf{• Then explain how convert this pseudo-poly-time dynamic program into PTAS.}  \\ \newline
For each of the task $p_i$, there are only $m = 3$ possible scheduling policies (on machine 1 or 2 or 3), so in all there is $3^n$ feasible solutions. We can order the $n$ tasks in decreasing order based on their cost. From the hint, we can consider all the feasible solutions as tree, where for each level, it decides on which machine it runs. For level 1, $p1$ task will be running on machine 1 if it is the 1st child of root node, on machine 2 if it is the 2nd, and machine 3 if it is the 3rd. We can do a simple greedy algorithm to get 2 approximation by assigning task i to machine j with the fastest completion time. It is a 2 approximation because the last machine i which is assigned with last job j, is the machine with least workload at that time. And by pending the last task, it would increase at most optimal time which makes it twice the optimal at most.
\\ \newline
Given a $\epsilon$, we give an algorithm to reduce the number of feasible of solutions, and show that this dp can be done in $O(n^{\frac{1}{\epsilon}})$ with $1+\epsilon$ approximation. We could stick to scheme before in finding the schedule for task $i$ where $p_i \leq \epsilon Optimal$ first, and append the rest of task $i$ where $p_i > \epsilon Optimal$ on the machine assigned with least tasks. Support machine $i$ have the most tasks after scheduling, if all the tasks assigned to machine $j$ satisfy $p_j > \epsilon Optimal$, then it is less than $(1+\epsilon)Optimal$, otherwise, suppose task $k$ where $p_k \leq \epsilon Optimal$ is added to machine $j$. Then we know that before task $k$ is added, sum of time on machine i is $\leq sum of p \leq OPT$, by adding $j$, $sum_of_time_on_i \leq Optimal + p_k  \leq Optimal + \epsilon Optimal = (1+\epsilon)Optimal$. So this give an $1+\epsilon$ approximation. For the time complicity, find the optimal solution for $p_j > \epsilon Optimal$, will be at most $O(3^\frac{1}{\epsilon})$ (since the number of these task will be at most $\frac{3}{\epsilon}$), and appending  he rest of task $i$ where $p_i \leq \epsilon Optimal$ on the machine assigned with least tasks will obviously take poly-time.

\end{document}
