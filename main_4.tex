\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Assignment 4}
\author{Xiaoting Li (xil139)}
\date{}

\begin{document}

\maketitle

\noindent
\textbf{7. For each of the next 4 algorithms, state whether the algorithm is a polynomial time algorithm, whether the algorithm is a pseudo-polynomial time algorithm, and whether the algorithm is a strongly polynomial time algorithm. Justify your answers.} \\ \newline
Answer: Assume $x_1, x_2, ..., x_n$ are m-bit integers. \\
(a) Since we assume $x_1, x_2, ..., x_n$ are m-bit positive integers, it means that we need to multiply each pair of m-bit positive numbers in two for-loops. The time complexity for multiplication is $O(m^{2})$. And since there are two for-loops, so the run-time is $O(n^{2}\cdot m{^2})$. This is polynomial time algorithm since it meets the definition of polynomial time when we consider the size of input instead of the numeric value of each input.\\
(b) Since the second loop is determined by the value of $x_i$ and we assume $x_1, x_2, ..., x_n$ are m-bit positive integers, so the run-time for this question is $O(n\cdot 2^{m}\cdot m{^2})$. This is a pseudo-polynomial time algorithm. Since the run-time is related with the numeric value of the input number. If we use unary coding or if we only consider the numeric value of the input instead of the size of the input, then this algorithm can be considered as polynomial time. \\
(c) The run-time of this one is $O(n\cdot m^{3})$. Since we assume each input is an $m$-bit integer, so $\log{x_i}$ is m. It is polynomial time. When we consider the size of input, it meets the definition of polynomial time.\\
(d) The run-time of this one is $O(n^{2})$. It is polynomial time as well as strong polynomial time. It has nothing do with the numeric value of input. It only relates to the number of loops.\\
(e) From the loop, we know the final value of y would be $y = y^2^n^2$, if we do this computation directly, it would be strong-poly time regardless of input size. However, if we go inside the nested loop, the time complicity of performing $y = y*y$ computation would be $O(2^{m}\cdot2^{m})$ suppose n is a m-bit positive integer, then it would be pseudo-poly time.
\\  \newline

\noindent
\textbf{8. Problem 16.4-4 from CLRS.} \\ \newline
Answer: In order to show $(S,I)$ is a matroid, we need to show that hereditary property and exchange property hold for elements in $I$. \\
1. Hereditary Property \\
Ley $X$ and $Y$ be two sets such that $X \in I$ and $Y \subset X$. From the definition of $I$, $X \cap S_i \leq 1$ for $i = 1, 2, ....., k$. If $Y \subset X$ then, $(Y \cap S_i) \in (X \cap S_i)$. So, $(Y \cap S_i) \leq (X \cap S_i) \leq 1$ for all $i$. Then we can say $Y \in I$ since the definition for $I$ holds for $Y$ too. So, the hereditary property holds. \\
2. Exchange Property \\
Let $X$ and $Y$ be two sets such that $X \in I$, $Y \in I$ and $|X| < |Y|$. In order to show that the exchange property holds, we need to show for some $x \in Y \setminus X$, $X \cup \{x\} \in I$.\\
 Assume $|Y \cap S_i| = 1$ and $Y \cap S_i = x$ and $X \cap S_i = \emptyset$ for some $i$. Then, $(X \cup \{x\}) \cap S_i = x$. And for any $j \neq i$, $(X \cup \{x\}) \cap S_j = (X \cap S_j)$. So, now we have $(X \cup \{x\}) \cap S_n \leq 1$ for all $n = 1, 2, ....., k$. Then, we can say  $(X \cup \{x\}) \in I$ and so, the exchange property holds.\\
Since the two properties hold, we can say $(S, I)$ is a matroid. \\ \newline

\noindent
\textbf{10. Problem 16-4 part a.} \\ \newline
\noindent
Answer: \\ \newline
\noindent
This algorithm is actually a greedy algorithm. We learn from Theorem 16.13 from the textbook that we can convert the unit-time scheduling problem into a matroid. So in this question what we need to is to prove that this greedy algorithm works on a matroid. \\ \newline
To prove this, we first assume that there is an optimal solution $Opt(I)$ and the greedy solution $G(I)$. From the question, we learn that if a task $a_j$ is scheduled before its deadline, it means that it swaps its time slot with some task that should be scheduled before deadline. Assume that $Opt(I)$ and $G(I)$ schedule tasks before $a_j$ in the same way. However, for $a_j$ the $Opt(I)$ schedules it after its deadline, which means there is some task $a_k$ that has higher penalty and swaps its time slot with some task that should be scheduled before the deadline. However, since $G(I)$ is a greedy algorithm, it always pick the available task that have the highest penalty. Therefore, this is a contradiction. So we can conclude that this algorithm always give an optimal answer.

\end{document}
