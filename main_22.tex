\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Assignment 22}
\author{Xiaoting Li (xil139) \\
Ziyu Zhang (ziz41) \\
Deniz Unal (des2014)}
\date{March 18 2019}

\begin{document}

\maketitle

\noindent
\textbf{34. Consider the problem of determining whether two sorted arrays A and B of numbers
contain a common number. That is whether there exists an $i$ and a $j$ such that
$A[i] = B[j]$. Let $C$ be the array of $2n$ numbers that would be formed by merging $A$
and $B$. Let $z_i$, $1 \leq i \leq 2n - 1$ 1 if $C[i]$ and $C[i + 1]$ came from different arrays initially, that is one of them came from $A$ and one of them came from $B$, and let $z_i$. Let $k = \sum_{i=1}^{2n-1}z_{i}$
be 0 otherwise. So intuitively $k$ is the number of times you have to switch between the two different lists in the merged order.} \\ \newline
\textbf{(a) Give a comparison based algorithm for determining whether $A$ and $B$ contain a
common number that runs in time $O(n)$.} \\ \newline
Answer: Assume there are two pointers, one pointer for array $A$ and the other pointer for array $B$. Start the the pointer for $A$ from $A[0]$ and the pointer for $B$ from $B[0]$. Compare $A[0]$ with $B[0]$. If $A[0] = B[0]$, output the result. Else if $A[0] < B[0]$, move the pointer for $A$ to the next position and compare $A[1]$ with $B[0]$. Else if $A[0] > B[0]$, move the pointer for $B$ to the next position and compare $A[0]$ with $B[1]$. Repeat these steps until the algorithm gets the common number. The worst case is to iterate both of the arrays, which is $2n$. So the algorithm runs in time $O(n)$.\\ \newline
\textbf{(b) Give a comparison based algorithm for determining whether $A$ and $B$ contain a
common number that runs in time $O(klogn)$.} \\ \newline
Answer: Do linear search in array $C$. Find $z_i = 1$ that is closest to the middle the array. Then compare $C[i] with C[i+1]$ to see if these two numbers are equal. If they are equal, output the result. Else, divide array $C$ into halves. For each half, repeat the above steps until the algorithm finds the common number. Each time it takes $O(k)$ to find $z_i = 1$ and takes $O(logn)$ to do the comparison. So the algorithm runs in time $O(klogn)$.\\ \newline
\textbf{(c) Prove when $k = O(n^9)$ then every comparison based algorithm for determining
whether $A$ and $B$ contain a common number uses at least $\Omega(klogn)$ comparisons.} \\ \newline
Answer: Adversary strategy. \\ \newline
\textbf{(extra credit) For some function $f(n,k)$ of your choosing, give a comparison based algorithm for determining whether $A$ and $B$ contain a common number that uses $O(f(n,k))$ comparisons, and show that every comparison based algorithm must use $\Omega (f(n,k))$ comparisons.} \\ \newline
\textbf{35. Consider a setting where you have two computer networking routers $A$ and $B$. Each router has collected a list $L_A$ and $L_B$ of IP source addresses for the packets that have passed through the router that day. An IP address is $n$ bits, and thus there are $2n$ possible IP addresses. Now the two routers want to communicate via a two-way channel to whether there was some source that sent a packet through one of the routers, but not the other. So more precisely, at the end of the protocol each router should commit to a bit specifying the answer to this question, and the bits for both routers should be correct. You can assume that each router can send a bit per unit time, and that a bit sent on the channel is guaranteed to arrive on the other end in one time unit. We want to consider protocols for accomplishing this goal.} \\ \newline
\textbf{(a) Consider the following protocol: $A$ sends to $B$ the list of all of the IP source addresses that it has seen; $B$ compares $A$â€™s list to its list, and then $B$ sends $A$ a 0 bit if the lists are identical and a 1 bit otherwise. Show that uses protocol about uses $n2^n+1$ bits in the worst case.}\\ \newline
Answer: In the worst case $A$ would have the all possible IP address combinations on its list. So it would need to send $n2^n$ bits to B since there are $2^n$ possible address combinations and each of them is $n$ bits. Then after the comparison, $B$ sends $A$ only 1 bit, 0 if the lists are identical and 1 otherwise. That means in the worst case there are $n2^n + 1$ bits used in this protocol. \\ \newline
\textbf{(b) Give a protocol that uses $2^n + O(1)$ bits in the worst case. } \\ \newline
Answer: In this protocol, instead of sending a list contains all the source IP addresses, $A$ sends a list of bits (call it $L_X$) to $B$ representing whether an address is on $L_A$ or not. $L_X$ would contain a single bit for each possible IP address in incremental order. For example, assume our addresses consist of 2 bits. and let $L_A$ has ``00, 01 and 11''  then the list that $A$ sends to $B$, $L_X$ would have ``1 1 0 1'' since the incremental order of all 2-bit addresses is ``00, 01, 10, 11'' and $A$ sends a 0 for the addresses that are not on $L_A$. With this protocol, since we are sending only 1 bit for each address and not the whole sequence, the number of bits $A$ sends is just the number of different possible IP addresses which is $2^n$. If $B$ responds the same way as in the protocol in the previous subproblem, in the worst case this protocol would use $2^n + O(1)$ bits.
\textbf{(c) Show that there is no protocol that can solve this problem without exchanging any bits.} \\ \newline
\textbf{(d) Show that there is no protocol that can solve this problem that involves $A$ sending one bit to $B$. And no more bits are exchanged.} \\ \newline
\textbf{(e) Show that there is no protocol that can solve this problem that involves $A$ sending one bit to $B$ and $B$ replying with one bit to $A$. And no more bits are exchanged.} \\ \newline
\textbf{(f) Prove that every protocol for this problem must send $2^n - O(1)$ bits for its worst case instance. Of course your proof should involve an adversarial argument.} \\ \newline
\textbf{(g) Show that if $k\leq 2n$ then every algorithm must use $\Omega(k)$ bits of memory.} \\ \newline

\end{document}
