\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Assignment 22}
\author{Xiaoting Li (xil139) \\
Ziyu Zhang (ziz41) \\
Deniz Unal (des204)}
\date{March 18 2019}

\begin{document}

\maketitle

\noindent
\textbf{34. Consider the problem of determining whether two sorted arrays A and B of numbers
contain a common number. That is whether there exists an $i$ and a $j$ such that
$A[i] = B[j]$. Let $C$ be the array of $2n$ numbers that would be formed by merging $A$
and $B$. Let $z_i$, $1 \leq i \leq 2n - 1$ 1 if $C[i]$ and $C[i + 1]$ came from different arrays initially, that is one of them came from $A$ and one of them came from $B$, and let $z_i$. Let $k = \sum_{i=1}^{2n-1}z_{i}$
be 0 otherwise. So intuitively $k$ is the number of times you have to switch between the two different lists in the merged order.} \\ \newline
\textbf{(a) Give a comparison based algorithm for determining whether $A$ and $B$ contain a
common number that runs in time $O(n)$.} \\ \newline
Answer: Assume there are two pointers, one pointer for array $A$ and the other pointer for array $B$. Start the the pointer for $A$ from $A[0]$ and the pointer for $B$ from $B[0]$. Compare $A[0]$ with $B[0]$. If $A[0] = B[0]$, output the result. Else if $A[0] < B[0]$, move the pointer for $A$ to the next position and compare $A[1]$ with $B[0]$. Else if $A[0] > B[0]$, move the pointer for $B$ to the next position and compare $A[0]$ with $B[1]$. Repeat these steps until the algorithm gets the common number. The worst case is to iterate both of the arrays, which is $2n$. So the algorithm runs in time $O(n)$.\\ \newline
\textbf{(b) Give a comparison based algorithm for determining whether $A$ and $B$ contain a
common number that runs in time $O(klogn)$.} \\ \newline
Answer: Do linear search in array $C$. Find $z_i = 1$ that is closest to the middle the array. Then compare $C[i] with C[i+1]$ to see if these two numbers are equal. If they are equal, output the result. Else, divide array $C$ into halves. For each half, repeat the above steps until the algorithm finds the common number. Each time it takes $O(k)$ to find $z_i = 1$ and takes $O(logn)$ to do the comparison. So the algorithm runs in time $O(klogn)$.\\ \newline
\textbf{(c) Prove when $k = O(n^9)$ then every comparison based algorithm for determining
whether $A$ and $B$ contain a common number uses at least $\Omega(klogn)$ comparisons.} \\ \newline
Answer: Answer: Let $S$ be an arbitrary comparison based algorithm. And assume there is an adversarial strategy playing against $S$. Since $k$ is the number of times we need to switch between the two different lists in the merged order. And we learn that $k = O(n^9)$. It means the adversarial strategy takes at most $O(n^9)$ switches to get the answer. After each switch, we compare $C[i]$ with $C[i+1]$. The run time is $log(n!\big(_n^k)) = \Omega(klgn)$ \\ \newline
\textbf{(extra credit) For some function $f(n,k)$ of your choosing, give a comparison based algorithm for determining whether $A$ and $B$ contain a common number that uses $O(f(n,k))$ comparisons, and show that every comparison based algorithm must use $\Omega (f(n,k))$ comparisons.} \\ \newline
\textbf{35. Consider a setting where you have two computer networking routers $A$ and $B$. Each router has collected a list $L_A$ and $L_B$ of IP source addresses for the packets that have passed through the router that day. An IP address is $n$ bits, and thus there are $2n$ possible IP addresses. Now the two routers want to communicate via a two-way channel to whether there was some source that sent a packet through one of the routers, but not the other. So more precisely, at the end of the protocol each router should commit to a bit specifying the answer to this question, and the bits for both routers should be correct. You can assume that each router can send a bit per unit time, and that a bit sent on the channel is guaranteed to arrive on the other end in one time unit. We want to consider protocols for accomplishing this goal.} \\ \newline
\textbf{(a) Consider the following protocol: $A$ sends to $B$ the list of all of the IP source addresses that it has seen; $B$ compares $A$’s list to its list, and then $B$ sends $A$ a 0 bit if the lists are identical and a 1 bit otherwise. Show that uses protocol about uses $n2^n+1$ bits in the worst case.}\\ \newline
Answer: In the worst case $A$ would have the all possible IP address combinations on its list. So it would need to send $n2^n$ bits to B since there are $2^n$ possible address combinations and each of them is $n$ bits. Then after the comparison, $B$ sends $A$ only 1 bit, 0 if the lists are identical and 1 otherwise. That means in the worst case there are $n2^n + 1$ bits used in this protocol. \\ \newline
\textbf{(b) Give a protocol that uses $2^n + O(1)$ bits in the worst case. } \\ \newline
Answer: In this protocol, instead of sending a list contains all the source IP addresses, $A$ sends a list of bits (call it $L_X$) to $B$ representing whether an address is on $L_A$ or not. $L_X$ would contain a single bit for each possible IP address in incremental order. For example, assume our addresses consist of 2 bits. and let $L_A$ has ``00, 01 and 11''  then the list that $A$ sends to $B$, $L_X$ would have ``1 1 0 1'' since the incremental order of all 2-bit addresses is ``00, 01, 10, 11'' and $A$ sends a 0 for the addresses that are not on $L_A$. With this protocol, since we are sending only 1 bit for each address and not the whole sequence, the number of bits $A$ sends is just the number of different possible IP addresses which is $2^n$. If $B$ responds the same way as in the protocol in the previous subproblem, in the worst case this protocol would use $2^n + O(1)$ bits.  \\ \newline
\textbf{(c) Show that there is no protocol that can solve this problem without exchanging any bits.} \\ \newline
Answer:  We assume that there exists a protocol that is capable of solving the problem without exchanging any bits. There are two possibilities for $B$ to respond with, $B$ can decide that the two lists are identical or not. If $B$ decides that the two lists are not identical, an adversary can show a situation where they are. If $B$ decides that the two lists are identical, the adversary can show a situation where they are not since $B$ will not know whether the two lists are identical or not. So, there is a possibility that the protocol is not correct. So, it is impossible to solve this problem without exchanging any bits.\\ \newline
\textbf{(d) Show that there is no protocol that can solve this problem that involves $A$ sending one bit to $B$. And no more bits are exchanged.} \\ \newline
Answer: We assume there is a protocol that is capable of solving this problem by $A$ sending one bit to $B$. If the bit that $A$ sends is 0, then it should mean the two lists $L_A$ and $L_B$ are identical. Then the adversarial strategy can show one $L_B$ that is not identical with $L_A$. In contrast, if the bit that $A$ sends is 1, then it should mean $L_A$ and $L_B$ are not identical and the adversarial strategy can make $L_B = L_A$. Then, we can say for a protocol that involves sending a single bit, it is incorrect. \\ \newline
\textbf{(e) Show that there is no protocol that can solve this problem that involves $A$ sending one bit to $B$ and $B$ replying with one bit to $A$. And no more bits are exchanged.} \\ \newline
Answer: We assume there is a protocol that is capable of solving this problem that involves $A$ sending one bit to $B$ and $B$ replying with one bit. There are four possibilities: \\
1) If $A$ sends 1 and $B$ replies with 0, it means that $L_A$ and $L_B$ are identical. The adversarial strategy can show one $L_A$ that is not identical to $L_B$. \\
2) If $A$ sends 1 and $B$ replies with 1, it means that $L_A$ and $L_B$ are not identical. The adversarial strategy can show one $L_A = L_B$. \\
3) If $A$ sends 0 and $B$ replies with 0, it means that $L_A$ and $L_B$ are identical. The adversarial strategy can show one $L_A$ that is not identical to $L_B$. \\
4) If $A$ sends 0 and $B$ replies with 1, it means that $L_A$ and $L_B$ are not identical. The adversarial strategy can show one $L_A = L_B$. \\
In all 4 possibilities, the adversarial strategy showed inconsistent results which implies that this protocol cannot be correct. \\ \newline
\textbf{(f) Prove that every protocol for this problem must send $2^n - O(1)$ bits for its worst case instance. Of course your proof should involve an adversarial argument.} \\ \newline
Answer: The input for the adversarial strategy would be the elements of $L_A$ and $L_B$ (because it is going to be comparing these two) and the output of it will be the decision (whether the two elements compared are equal or not). So, if there are $x$ decisions to be made, the number of permutations of decisions that the adversary can come up with is $2^x$ (since a decision can have 2 values, equal or not). As we said in the previous subproblems, in the worst case, $A$ would have $2^n$ IP addresses and in subproblem b we showed that we can represent existence or absence of an IP address with a single bit in $L_A$. So, the number of permutations of the elements of $L_A$ is $2^{2^n}$ since all $2^n$ elements can be either a 0 or 1. Since the adversarial strategy is maximizing the number of permutations, the number of permutations of elements in $L_A$ should be less than or equal to the number of permutations of decisions that the adversary can come up with. Then there needs to be at least $2^n$ bit transmissions from $A$ since $x \geq 2^n$. To make this bound even tighter we can say that the protocol does not need to transfer any bit after the first mismatch is caught. So, if we call the number of bits that remain to be sent after the first mistmatch $r$, $A$ needs to send only $2^n - r$ bits. Then again, $B$ would reply with one bit, 0 if $L_A = L_B$ and 1 ottherwise. Then the total number of bits need to be exchanged is $2^n - r + 1$ which is $2^n - O(1)$. \\ \newline
\textbf{(g) Show that if $k\leq 2^n$ then every algorithm must use $\Omega(k)$ bits of memory.} \\ \newline
Answer: We assume there exists an algorithm that is capable of solving this problem using $o(k)$ bits of memory. Which means this algorithm can solve this problem using less than $2^n$ bits of memory. In the previous subproblems we showed that any algorithm using less than $2^n$ bits (transfering in those problems) is incorrect and an agorithm should use at least $2^n$ bits in the worst case. So, in this problem we would need at least $k$ bits of memory which is $\Omega(k)$. \\ \newline

\end{document}
